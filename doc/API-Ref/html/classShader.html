<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>VoltAir: Shader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">VoltAir
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classShader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Shader Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__Renderer.html">Game-specific OpenGL renderer and helper classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classShader.html" title="Shader program abstract base class. ">Shader</a> program abstract base class.  
 <a href="classShader.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Shader:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classShader.png" usemap="#Shader_map" alt=""/>
  <map id="Shader_map" name="Shader_map">
<area href="classInstancedShader.html" title="Shader which has instanced values for uniforms and other GL state. " alt="InstancedShader" shape="rect" coords="295,56,580,80"/>
<area href="classShaderBase.html" title="Implementation of Shader which compiles itself from shader code. " alt="ShaderBase" shape="rect" coords="590,56,875,80"/>
<area href="classInstancedShaderBase.html" title="Helper class to implement InstancedShader subclasses, by managing a shared Shader. " alt="InstancedShaderBase&lt; TShaderImpl &gt;" shape="rect" coords="0,112,285,136"/>
<area href="classInstancedShaderBase.html" alt="InstancedShaderBase&lt; SpriteShader &gt;" shape="rect" coords="295,112,580,136"/>
<area href="classTerrainShader.html" title="InstancedShader which does a multi-texture blend between up to three Textures, to render terrain mesh..." alt="TerrainShader" shape="rect" coords="590,112,875,136"/>
<area href="classSingletonInstancedShaderBase.html" title="A helper to define singletons for InstancedShaders. " alt="SingletonInstancedShaderBase&lt; TShaderImpl &gt;" shape="rect" coords="0,168,285,192"/>
<area href="classSingletonInstancedShaderBase.html" alt="SingletonInstancedShaderBase&lt; SpriteShader &gt;" shape="rect" coords="295,168,580,192"/>
<area href="classSpriteShader.html" title="Shader use by Renderer to draw textured rectangles (sprites). " alt="SpriteShader" shape="rect" coords="295,224,580,248"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abf12daba1e6fe9bd895c2b3973cf4be4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShader.html#abf12daba1e6fe9bd895c2b3973cf4be4">Shader</a> (const <a class="el" href="group__Renderer.html#ga4ac5fb30eab3c3b4ecff5fb9869bd8f4">AttributeSetPtr</a> &amp;attributes, const std::vector&lt; std::string &gt; &amp;uniformNames)</td></tr>
<tr class="memdesc:abf12daba1e6fe9bd895c2b3973cf4be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classShader.html" title="Shader program abstract base class. ">Shader</a> with the given list of attributes and uniforms.  <a href="#abf12daba1e6fe9bd895c2b3973cf4be4">More...</a><br /></td></tr>
<tr class="separator:abf12daba1e6fe9bd895c2b3973cf4be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce0b1803683db46af81162967a3872b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShader.html#a7ce0b1803683db46af81162967a3872b">isCurrent</a> () const =0</td></tr>
<tr class="memdesc:a7ce0b1803683db46af81162967a3872b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this shader is bound.  <a href="#a7ce0b1803683db46af81162967a3872b">More...</a><br /></td></tr>
<tr class="separator:a7ce0b1803683db46af81162967a3872b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5acf537f2d622482bba9eb4998bb58"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShader.html#ada5acf537f2d622482bba9eb4998bb58">isValid</a> () const =0</td></tr>
<tr class="memdesc:ada5acf537f2d622482bba9eb4998bb58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this shader is valid (compiled and linked) and can be used for rendering.  <a href="#ada5acf537f2d622482bba9eb4998bb58">More...</a><br /></td></tr>
<tr class="separator:ada5acf537f2d622482bba9eb4998bb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab185557c193a1a9b9de5ac4905f70b73"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShader.html#ab185557c193a1a9b9de5ac4905f70b73">isCompiled</a> () const =0</td></tr>
<tr class="memdesc:ab185557c193a1a9b9de5ac4905f70b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this shader has been processed for compilation.  <a href="#ab185557c193a1a9b9de5ac4905f70b73">More...</a><br /></td></tr>
<tr class="separator:ab185557c193a1a9b9de5ac4905f70b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9469136bf381b5a3acc08f530f8511"><td class="memItemLeft" align="right" valign="top">virtual GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShader.html#aaf9469136bf381b5a3acc08f530f8511">getProgramId</a> () const =0</td></tr>
<tr class="memdesc:aaf9469136bf381b5a3acc08f530f8511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the GL program id for this shader.  <a href="#aaf9469136bf381b5a3acc08f530f8511">More...</a><br /></td></tr>
<tr class="separator:aaf9469136bf381b5a3acc08f530f8511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c670da5cebdd41def63b171c717cd0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShader.html#a88c670da5cebdd41def63b171c717cd0">begin</a> ()=0</td></tr>
<tr class="memdesc:a88c670da5cebdd41def63b171c717cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds this shader, updating state as necessary.  <a href="#a88c670da5cebdd41def63b171c717cd0">More...</a><br /></td></tr>
<tr class="separator:a88c670da5cebdd41def63b171c717cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c220646293dbcb5f4d9be750bc3e9ba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShader.html#a2c220646293dbcb5f4d9be750bc3e9ba">end</a> ()=0</td></tr>
<tr class="memdesc:a2c220646293dbcb5f4d9be750bc3e9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbinds this shader if bound by a corresponding call to <a class="el" href="classShader.html#a88c670da5cebdd41def63b171c717cd0" title="Binds this shader, updating state as necessary. ">begin()</a>.  <a href="#a2c220646293dbcb5f4d9be750bc3e9ba">More...</a><br /></td></tr>
<tr class="separator:a2c220646293dbcb5f4d9be750bc3e9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae510a4880da2bde580233e16ab2754a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShader.html#ae510a4880da2bde580233e16ab2754a9">compile</a> ()=0</td></tr>
<tr class="memdesc:ae510a4880da2bde580233e16ab2754a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles this shader, if not already compiled.  <a href="#ae510a4880da2bde580233e16ab2754a9">More...</a><br /></td></tr>
<tr class="separator:ae510a4880da2bde580233e16ab2754a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5f3f792a4c052f305fecef471eeb0c"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShader.html#a1b5f3f792a4c052f305fecef471eeb0c">getErrorLog</a> () const =0</td></tr>
<tr class="memdesc:a1b5f3f792a4c052f305fecef471eeb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the string describing compilation errors, if the call to <a class="el" href="classShader.html#ae510a4880da2bde580233e16ab2754a9" title="Compiles this shader, if not already compiled. ">compile()</a> failed and <a class="el" href="classShader.html#ada5acf537f2d622482bba9eb4998bb58" title="Returns whether or not this shader is valid (compiled and linked) and can be used for rendering...">isValid()</a> is <code>false</code>.  <a href="#a1b5f3f792a4c052f305fecef471eeb0c">More...</a><br /></td></tr>
<tr class="separator:a1b5f3f792a4c052f305fecef471eeb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2effd975eeb20dd549ae4b17730473"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__Renderer.html#ga4ac5fb30eab3c3b4ecff5fb9869bd8f4">AttributeSetPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShader.html#a1c2effd975eeb20dd549ae4b17730473">getAttributes</a> () const </td></tr>
<tr class="memdesc:a1c2effd975eeb20dd549ae4b17730473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of indexed <a class="el" href="structAttribute.html" title="The definition of a vertex attribute, such as a position vector, or a texture coordinate. ">Attribute</a>s for this shader, as an <a class="el" href="structAttributeSet.html" title="A list of vertex attributes. ">AttributeSet</a>.  <a href="#a1c2effd975eeb20dd549ae4b17730473">More...</a><br /></td></tr>
<tr class="separator:a1c2effd975eeb20dd549ae4b17730473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d7ac1caf84eaa8bc795cb481cc0bbb"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShader.html#a10d7ac1caf84eaa8bc795cb481cc0bbb">getUniformNames</a> () const </td></tr>
<tr class="memdesc:a10d7ac1caf84eaa8bc795cb481cc0bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of indexed uniforms.  <a href="#a10d7ac1caf84eaa8bc795cb481cc0bbb">More...</a><br /></td></tr>
<tr class="separator:a10d7ac1caf84eaa8bc795cb481cc0bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108d1e4011a520e1880cc701a5d684ba"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShader.html#a108d1e4011a520e1880cc701a5d684ba">getAttributeLocation</a> (int index) const =0</td></tr>
<tr class="memdesc:a108d1e4011a520e1880cc701a5d684ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the location of an indexed <a class="el" href="structAttribute.html" title="The definition of a vertex attribute, such as a position vector, or a texture coordinate. ">Attribute</a>.  <a href="#a108d1e4011a520e1880cc701a5d684ba">More...</a><br /></td></tr>
<tr class="separator:a108d1e4011a520e1880cc701a5d684ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807e5a539e99d658e9987f502e94b2e0"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShader.html#a807e5a539e99d658e9987f502e94b2e0">getUniformLocation</a> (int index) const =0</td></tr>
<tr class="memdesc:a807e5a539e99d658e9987f502e94b2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the location of an indexed uniform.  <a href="#a807e5a539e99d658e9987f502e94b2e0">More...</a><br /></td></tr>
<tr class="separator:a807e5a539e99d658e9987f502e94b2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833b46910fd9639e3f6b15494515e9c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShader.html#a833b46910fd9639e3f6b15494515e9c5">setIndexedUniform1f</a> (int index, bool global, float value, float *stateValue)</td></tr>
<tr class="memdesc:a833b46910fd9639e3f6b15494515e9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a float scalar uniform at the given <code>index</code>.  <a href="#a833b46910fd9639e3f6b15494515e9c5">More...</a><br /></td></tr>
<tr class="separator:a833b46910fd9639e3f6b15494515e9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157feaa43eff1bcb81382b4e6b533a17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShader.html#a157feaa43eff1bcb81382b4e6b533a17">setIndexedUniform2f</a> (int index, bool global, const <a class="el" href="RendererCommon_8h.html#ac41ea418abac18d703df1b41c255ee26">Vector2</a> &amp;value, <a class="el" href="RendererCommon_8h.html#ac41ea418abac18d703df1b41c255ee26">Vector2</a> *stateValue)</td></tr>
<tr class="memdesc:a157feaa43eff1bcb81382b4e6b533a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a 2D float vector uniform at the given <code>index</code>.  <a href="#a157feaa43eff1bcb81382b4e6b533a17">More...</a><br /></td></tr>
<tr class="separator:a157feaa43eff1bcb81382b4e6b533a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfade5187d0fd5ea5c5f9857220f6ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShader.html#a9bfade5187d0fd5ea5c5f9857220f6ec">setIndexedUniform3f</a> (int index, bool global, float value1, float value2, float value3, float *stateValue)</td></tr>
<tr class="memdesc:a9bfade5187d0fd5ea5c5f9857220f6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a 3D float vector uniform at the given <code>index</code>.  <a href="#a9bfade5187d0fd5ea5c5f9857220f6ec">More...</a><br /></td></tr>
<tr class="separator:a9bfade5187d0fd5ea5c5f9857220f6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd8df1d88b6aff80adfabc1b3bb0900"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShader.html#a6fd8df1d88b6aff80adfabc1b3bb0900">setIndexedUniform4f</a> (int index, bool global, float value1, float value2, float value3, float value4, float *stateValue)</td></tr>
<tr class="memdesc:a6fd8df1d88b6aff80adfabc1b3bb0900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a 4D float vector uniform at the given <code>index</code>.  <a href="#a6fd8df1d88b6aff80adfabc1b3bb0900">More...</a><br /></td></tr>
<tr class="separator:a6fd8df1d88b6aff80adfabc1b3bb0900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292c0cacb915708bcbb3c8852849e8a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShader.html#a292c0cacb915708bcbb3c8852849e8a0">setIndexedUniform1i</a> (int index, bool global, int value, int *stateValue)</td></tr>
<tr class="memdesc:a292c0cacb915708bcbb3c8852849e8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of an integer scalar uniform at the given <code>index</code>.  <a href="#a292c0cacb915708bcbb3c8852849e8a0">More...</a><br /></td></tr>
<tr class="separator:a292c0cacb915708bcbb3c8852849e8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ef7ed29616b72a1918ae63d591ffe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShader.html#a95ef7ed29616b72a1918ae63d591ffe2">setIndexedUniformMatrix4f</a> (int index, bool global, bool transpose, const <a class="el" href="RendererCommon_8h.html#a32aa8cc71a1b7a21fc790cee97ce40d5">Matrix4</a> &amp;value, <a class="el" href="RendererCommon_8h.html#a32aa8cc71a1b7a21fc790cee97ce40d5">Matrix4</a> *stateValue)</td></tr>
<tr class="memdesc:a95ef7ed29616b72a1918ae63d591ffe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a 4x4 float matrix uniform at the given <code>index</code>.  <a href="#a95ef7ed29616b72a1918ae63d591ffe2">More...</a><br /></td></tr>
<tr class="separator:a95ef7ed29616b72a1918ae63d591ffe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classShader.html" title="Shader program abstract base class. ">Shader</a> program abstract base class. </p>
<p>This class is a wrapper around a GL program, with the added concept of indexed attributes and uniforms. Indexed attributes and uniforms allow attributes and uniforms to be referenced by index, rather than name, for efficient lookups. The index of an attribute or uniform is determined by its index into the list of attributes and uniforms passed into <a class="el" href="classShader.html" title="Shader program abstract base class. ">Shader</a>'s constructor. For example, if you provide the list of uniforms, <code>"color", "offset", "direction"</code>, the uniform <code>color</code> would have index 0, <code>offset</code> index 1, and <code>direction</code> index 2. These indices can be provided to functions like <a class="el" href="classShader.html#a108d1e4011a520e1880cc701a5d684ba" title="Returns the location of an indexed Attribute. ">getAttributeLocation()</a>, <a class="el" href="classShader.html#a807e5a539e99d658e9987f502e94b2e0" title="Returns the location of an indexed uniform. ">getUniformLocation()</a>, and the <code>setIndexed</code> family of functions such as <a class="el" href="classShader.html#a95ef7ed29616b72a1918ae63d591ffe2" title="Set the value of a 4x4 float matrix uniform at the given index. ">setIndexedUniformMatrix4f()</a>.</p>
<p>See <a class="el" href="classInstancedShader.html" title="Shader which has instanced values for uniforms and other GL state. ">InstancedShader</a> for the details on how to use the <code>setIndexed</code> family of methods to implement an instanced shader.</p>
<p><a class="el" href="classShader.html" title="Shader program abstract base class. ">Shader</a>s can either be used on their own as wrappers around GL programs and managers of their state or in conjunction with <a class="el" href="classRenderer.html" title="Class managing GL state switches and draw calls. ">Renderer</a>. If used with <a class="el" href="classRenderer.html" title="Class managing GL state switches and draw calls. ">Renderer</a>, <a class="el" href="classShader.html#a88c670da5cebdd41def63b171c717cd0" title="Binds this shader, updating state as necessary. ">begin()</a> and <a class="el" href="classShader.html#a2c220646293dbcb5f4d9be750bc3e9ba" title="Unbinds this shader if bound by a corresponding call to begin(). ">end()</a> will be called as needed when selected. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abf12daba1e6fe9bd895c2b3973cf4be4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Shader::Shader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Renderer.html#ga4ac5fb30eab3c3b4ecff5fb9869bd8f4">AttributeSetPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>uniformNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classShader.html" title="Shader program abstract base class. ">Shader</a> with the given list of attributes and uniforms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attributes</td><td><a class="el" href="structAttributeSet.html" title="A list of vertex attributes. ">AttributeSet</a> containing the list of indexed attributes for this shader </td></tr>
    <tr><td class="paramname">uniformNames</td><td>List of indexed uniforms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a88c670da5cebdd41def63b171c717cd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Shader::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds this shader, updating state as necessary. </p>

<p>Implemented in <a class="el" href="classInstancedShader.html#a833ac6d7a9cf420bfc29b1e8e208ebae">InstancedShader</a>, and <a class="el" href="classShaderBase.html#acaeb738a732e8ccd835edd83e25e95a8">ShaderBase</a>.</p>

</div>
</div>
<a class="anchor" id="ae510a4880da2bde580233e16ab2754a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Shader::compile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compiles this shader, if not already compiled. </p>

<p>Implemented in <a class="el" href="classInstancedShader.html#aa66cb46f86d1c0ea087539fcff5826b7">InstancedShader</a>, and <a class="el" href="classShaderBase.html#acc7ddde0c310be88dee8d01b51490584">ShaderBase</a>.</p>

</div>
</div>
<a class="anchor" id="a2c220646293dbcb5f4d9be750bc3e9ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Shader::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unbinds this shader if bound by a corresponding call to <a class="el" href="classShader.html#a88c670da5cebdd41def63b171c717cd0" title="Binds this shader, updating state as necessary. ">begin()</a>. </p>

<p>Implemented in <a class="el" href="classInstancedShader.html#ad43827e7d375b87257588aa0d05b727d">InstancedShader</a>, and <a class="el" href="classShaderBase.html#a0e8ed7fb0c4982feada222064ce9bb06">ShaderBase</a>.</p>

</div>
</div>
<a class="anchor" id="a108d1e4011a520e1880cc701a5d684ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Shader::getAttributeLocation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the location of an indexed <a class="el" href="structAttribute.html" title="The definition of a vertex attribute, such as a position vector, or a texture coordinate. ">Attribute</a>. </p>
<p>Indexed attributes are those that are named in the <a class="el" href="structAttributeSet.html" title="A list of vertex attributes. ">AttributeSet</a> provided to the shader's constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index into the list of attributes </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classInstancedShader.html#a4005c2e2ab8778f3bc1a03cebbe3853a">InstancedShader</a>, and <a class="el" href="classShaderBase.html#a4296376b1272854b751156a91d57e9ad">ShaderBase</a>.</p>

</div>
</div>
<a class="anchor" id="a1c2effd975eeb20dd549ae4b17730473"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__Renderer.html#ga4ac5fb30eab3c3b4ecff5fb9869bd8f4">AttributeSetPtr</a>&amp; Shader::getAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the list of indexed <a class="el" href="structAttribute.html" title="The definition of a vertex attribute, such as a position vector, or a texture coordinate. ">Attribute</a>s for this shader, as an <a class="el" href="structAttributeSet.html" title="A list of vertex attributes. ">AttributeSet</a>. </p>

</div>
</div>
<a class="anchor" id="a1b5f3f792a4c052f305fecef471eeb0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Shader::getErrorLog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the string describing compilation errors, if the call to <a class="el" href="classShader.html#ae510a4880da2bde580233e16ab2754a9" title="Compiles this shader, if not already compiled. ">compile()</a> failed and <a class="el" href="classShader.html#ada5acf537f2d622482bba9eb4998bb58" title="Returns whether or not this shader is valid (compiled and linked) and can be used for rendering...">isValid()</a> is <code>false</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>String describing compilation errors </dd></dl>

<p>Implemented in <a class="el" href="classInstancedShader.html#a1b62fa39a49cb4e3505949122445c5eb">InstancedShader</a>, and <a class="el" href="classShaderBase.html#a3247d98529b95abc5cd597900437caa9">ShaderBase</a>.</p>

</div>
</div>
<a class="anchor" id="aaf9469136bf381b5a3acc08f530f8511"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual GLuint Shader::getProgramId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the GL program id for this shader. </p>

<p>Implemented in <a class="el" href="classInstancedShader.html#a4b1e1aeb3f519415e23fed7c69ee71da">InstancedShader</a>, and <a class="el" href="classShaderBase.html#a42a0bbfe13c66310af87c4401f6c3a6c">ShaderBase</a>.</p>

</div>
</div>
<a class="anchor" id="a807e5a539e99d658e9987f502e94b2e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Shader::getUniformLocation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the location of an indexed uniform. </p>
<p>Indexed uniforms are those that are named in the list of uniforms provided to the shader's constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index into the list of uniforms </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classInstancedShader.html#acb1fef3b2bb330732689ca0123dd9256">InstancedShader</a>, and <a class="el" href="classShaderBase.html#a8d32e328a8b39df2aa5cc9841ff07554">ShaderBase</a>.</p>

</div>
</div>
<a class="anchor" id="a10d7ac1caf84eaa8bc795cb481cc0bbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; Shader::getUniformNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the list of indexed uniforms. </p>

</div>
</div>
<a class="anchor" id="ab185557c193a1a9b9de5ac4905f70b73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Shader::isCompiled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this shader has been processed for compilation. </p>
<dl class="section note"><dt>Note</dt><dd>This does not indicate whether compilation succeeded. To test for success, use <a class="el" href="classShader.html#ada5acf537f2d622482bba9eb4998bb58" title="Returns whether or not this shader is valid (compiled and linked) and can be used for rendering...">isValid()</a>. </dd></dl>

<p>Implemented in <a class="el" href="classInstancedShader.html#a870ea2ce77384daf3cd7e6dc70147973">InstancedShader</a>, and <a class="el" href="classShaderBase.html#a8bc915072d9602e78fbc9649969f48ef">ShaderBase</a>.</p>

</div>
</div>
<a class="anchor" id="a7ce0b1803683db46af81162967a3872b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Shader::isCurrent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this shader is bound. </p>

<p>Implemented in <a class="el" href="classInstancedShader.html#aca131de4549cd732de520b8e319b15ff">InstancedShader</a>, and <a class="el" href="classShaderBase.html#a9a6edb37164f1660e41226609f08660d">ShaderBase</a>.</p>

</div>
</div>
<a class="anchor" id="ada5acf537f2d622482bba9eb4998bb58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Shader::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this shader is valid (compiled and linked) and can be used for rendering. </p>

<p>Implemented in <a class="el" href="classInstancedShader.html#a1dc3737e024a0728c150dc00956368c5">InstancedShader</a>, and <a class="el" href="classShaderBase.html#a2be77dc589ff7e7520121e0d43b9bd11">ShaderBase</a>.</p>

</div>
</div>
<a class="anchor" id="a833b46910fd9639e3f6b15494515e9c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shader::setIndexedUniform1f </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>stateValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a float scalar uniform at the given <code>index</code>. </p>
<p>See <a class="el" href="classInstancedShader.html" title="Shader which has instanced values for uniforms and other GL state. ">InstancedShader</a> for details on the <code>setIndexed</code> family of methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the uniform to set </td></tr>
    <tr><td class="paramname">global</td><td>Whether or not this uniform is global and should be set even if the shader is not bound </td></tr>
    <tr><td class="paramname">value</td><td>Scalar value to set </td></tr>
    <tr><td class="paramname">stateValue</td><td>Memory to save off state to, or <code>nullptr</code> if state should not be saved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a292c0cacb915708bcbb3c8852849e8a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shader::setIndexedUniform1i </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>stateValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of an integer scalar uniform at the given <code>index</code>. </p>
<p>See <a class="el" href="classInstancedShader.html" title="Shader which has instanced values for uniforms and other GL state. ">InstancedShader</a> for details on the <code>setIndexed</code> family of methods. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the uniform to set </td></tr>
    <tr><td class="paramname">global</td><td>Whether or not this uniform is global and should be set even if the shader is not bound </td></tr>
    <tr><td class="paramname">value</td><td>Scalar value to set </td></tr>
    <tr><td class="paramname">stateValue</td><td>Memory to save off state to, or <code>nullptr</code> if state should not be saved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a157feaa43eff1bcb81382b4e6b533a17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shader::setIndexedUniform2f </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="RendererCommon_8h.html#ac41ea418abac18d703df1b41c255ee26">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="RendererCommon_8h.html#ac41ea418abac18d703df1b41c255ee26">Vector2</a> *&#160;</td>
          <td class="paramname"><em>stateValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a 2D float vector uniform at the given <code>index</code>. </p>
<p>See <a class="el" href="classInstancedShader.html" title="Shader which has instanced values for uniforms and other GL state. ">InstancedShader</a> for details on the <code>setIndexed</code> family of methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the uniform to set </td></tr>
    <tr><td class="paramname">global</td><td>Whether or not this uniform is global and should be set even if the shader is not bound </td></tr>
    <tr><td class="paramname">value</td><td>Vector2 to set </td></tr>
    <tr><td class="paramname">stateValue</td><td>Memory to save off state to, or <code>nullptr</code> if state should not be saved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9bfade5187d0fd5ea5c5f9857220f6ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shader::setIndexedUniform3f </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>stateValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a 3D float vector uniform at the given <code>index</code>. </p>
<p>See <a class="el" href="classInstancedShader.html" title="Shader which has instanced values for uniforms and other GL state. ">InstancedShader</a> for details on the <code>setIndexed</code> family of methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the uniform to set </td></tr>
    <tr><td class="paramname">global</td><td>Whether or not this uniform is global and should be set even if the shader is not bound </td></tr>
    <tr><td class="paramname">value1</td><td>First vector element </td></tr>
    <tr><td class="paramname">value2</td><td>Second vector element </td></tr>
    <tr><td class="paramname">value3</td><td>Third vector element </td></tr>
    <tr><td class="paramname">stateValue</td><td>Memory to save off state to, or <code>nullptr</code> if state should not be saved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6fd8df1d88b6aff80adfabc1b3bb0900"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shader::setIndexedUniform4f </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>stateValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a 4D float vector uniform at the given <code>index</code>. </p>
<p>See <a class="el" href="classInstancedShader.html" title="Shader which has instanced values for uniforms and other GL state. ">InstancedShader</a> for details on the <code>setIndexed</code> family of methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the uniform to set </td></tr>
    <tr><td class="paramname">global</td><td>Whether or not this uniform is global and should be set even if the shader is not bound </td></tr>
    <tr><td class="paramname">value1</td><td>First vector element </td></tr>
    <tr><td class="paramname">value2</td><td>Second vector element </td></tr>
    <tr><td class="paramname">value3</td><td>Third vector element </td></tr>
    <tr><td class="paramname">value4</td><td>Fourth vector element </td></tr>
    <tr><td class="paramname">stateValue</td><td>Memory to save off state to, or <code>nullptr</code> if state should not be saved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a95ef7ed29616b72a1918ae63d591ffe2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Shader::setIndexedUniformMatrix4f </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="RendererCommon_8h.html#a32aa8cc71a1b7a21fc790cee97ce40d5">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="RendererCommon_8h.html#a32aa8cc71a1b7a21fc790cee97ce40d5">Matrix4</a> *&#160;</td>
          <td class="paramname"><em>stateValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a 4x4 float matrix uniform at the given <code>index</code>. </p>
<p>See <a class="el" href="classInstancedShader.html" title="Shader which has instanced values for uniforms and other GL state. ">InstancedShader</a> for details on the <code>setIndexed</code> family of methods. </p><dl class="section note"><dt>Note</dt><dd>This method currently differs from <code>glUniformMatrix4fv()</code> in that only one matrix, not an array of matrices, can be uploaded. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the uniform to set </td></tr>
    <tr><td class="paramname">global</td><td>Whether or not this uniform is global and should be set even if the shader is not bound </td></tr>
    <tr><td class="paramname">transpose</td><td>Whether or not to upload this matrix transposed </td></tr>
    <tr><td class="paramname">value</td><td>Matrix to set </td></tr>
    <tr><td class="paramname">stateValue</td><td>Memory to save off state to, or <code>nullptr</code> if state should not be saved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-49880327-7', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
