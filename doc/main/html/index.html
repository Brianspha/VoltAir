<!doctype html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>VoltAir Build and Run Instructions: Main</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<script type="text/javascript">
$(document).ready(function(){
    $('.voltAirVideo').html("<iframe width=\"560\" height=\"315\" src=\"http://www.youtube.com/embed/EwyNqC7-lDw\" frameborder=\"0\" align=\"middle\" allowfullscreen></iframe>");
});
</script>
<!-- Generated by Doxygen 1.8.7 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">The VoltAir Project </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Overview</h2>
<p>For questions, comments, or concerns not addressed below, feel free to join and email the <a href="http://groups.google.com/d/forum/voltair-discuss">VoltAir discussion group</a>, or dicuss online using <code>#VoltAir</code> (e.g. on StackOverflow or Twitter).</p>
<div class="toc"> <ul>
<li>
<a href="#1">Overview</a> </li>
<li>
<a href="../../gettingStarted/html/index.html">Getting Started</a> </li>
<li>
<a href="../../contributing/html/index.html">Contributing</a> </li>
<li>
<a href="../../API-Ref/html/annotated.html">API Reference</a> </li>
</ul>
</div><ol type="1">
<li><a href="#1">What is VoltAir?</a></li>
<li><a href="#2">How do I get started using VoltAir?</a></li>
<li><a href="#3">Where can I find documentation on the VoltAir source code?</a></li>
<li><a href="#4">How do I contribute to the VoltAir project?</a></li>
<li><a href="#5">Why was VoltAir developed?</a></li>
<li><a href="#6">Is VoltAir still being developed?</a></li>
<li><a href="#7">What platforms can I build and run VoltAir on?</a></li>
<li><a href="#8">What versions of Android is VoltAir compatible with?</a></li>
<li><a href="#9">What devices is VoltAir known to run on and why aren't more devices supported?</a></li>
<li><a href="#10">Why did we choose to use C++?</a></li>
<li><a href="#11">Why did we choose to use Qt and what is QtQuick?</a></li>
<li><a href="#12">What is the high-level design of VoltAir?</a></li>
<li><a href="#13">What is GameInput, why did you build it, and how do you use it?</a></li>
<li><a href="#14">What is the VoltAir Renderer and what are some tricks behind the visuals?</a></li>
<li><a href="#15">What is the VoltAir Engine, and is it really a game engine?</a></li>
<li><a href="#16">Why is there all this JavaScript?</a></li>
<li><a href="#17">How did you design the UI?</a></li>
<li><a href="#18">If I want to develop my own new application based on the VoltAir source code, where do I start?</a></li>
<li><a href="#19">How did you integrate Box2D / LiquidFun?</a></li>
<li><a href="#20">How could I use the different particle types in LiquidFun and what other additional features could I add to VoltAir?</a></li>
<li><a href="#21">Where is the level editor?</a></li>
<li><a href="#22">Why aren't you using the Play Games Services C++ SDK?</a></li>
<li><a href="#23">What's the deal with the sound files in the open source code?</a></li>
<li><a href="#24">What workarounds did you need to implement?</a></li>
</ol>
<hr/>
<h2><a class="anchor" id="1"></a> What is VoltAir?</h2>
<p>The Fun Propulsion Labs at Google are quite proud to announce that VoltAir, a casual single and local multiplayer game, is now available on the <a href="https://play.google.com/store/apps/details?id=com.google.fpl.voltair">Google Play Store</a> and as <a href="../../gettingStarted/html/index.html">open source software</a>.</p>
<div class="voltAirVideo" align="center"></div><p>The game features a spunky, speedy robot stranded on an alien planet. Going as fast as his single wheel will carry him, he flies over ramps, zips around meteors, and rides geysers in his search for the portal that will take him home.</p>
<div class="image">
<img src="liquidfun-logo-horizontal-small.png"  alt="Powered By LiquidFun"/>
</div>
<p>VoltAir shows how versatile our LiquidFun tech can be when applied to a consumer application. LiquidFun is a C++ 2D physics library based on Box2D that includes high-performance particle simulation. It's used a few different ways in the game, as an obstacle for our little robot hero to work around, as a platform that lifts our hero to new heights, and simply as a way to add moving, splashing, graphic touches to levels.</p>
<p>We built the game on top of <a href="http://qt-project.org/doc/qt-5/qtquick-index.html">QtQuick</a>, which you can read more about <a href="#11">below</a>.</p>
<hr/>
<h2><a class="anchor" id="2"></a> How do I get started using VoltAir?</h2>
<p>You can download and play a <a href="https://play.google.com/store/apps/details?id=com.google.fpl.voltair">working copy of VoltAir</a> off of the Google Play Store or take a look at <a href="../../gettingStarted/html/index.html">the introduction to our open source project</a> to get started downloading, building, and running the project.</p>
<hr/>
<h2><a class="anchor" id="3"></a> Where can I find documentation on the VoltAir source code?</h2>
<p>To see our source code documentation, take a look at our <a href="../../API-Ref/html/annotated.html">API Reference</a>.</p>
<hr/>
<h2><a class="anchor" id="4"></a> How do I contribute to the VoltAir project?</h2>
<p>For information on working on the VoltAir project, please see our <a href="../../contributing/html/index.html">Contributing page</a>.</p>
<hr/>
<h2><a class="anchor" id="5"></a> Why was VoltAir developed?</h2>
<p>VoltAir was developed to provide an example of a C++ game designed for both Android and Android TV. For example, it shows on-screen controls when run on a mobile device, but does not show controls when on a TV. Additionally, VoltAir demonstrates controllers, local multiplayer in Android, and how to closely integrate <a href="https://google.github.io/liquidfun/">LiquidFun</a>.</p>
<p>VoltAir was not developed to compete with existing platform games, to make money, to provide a full-length game, or to actively promote the use of Qt in making games.</p>
<hr/>
<h2><a class="anchor" id="6"></a> Is VoltAir still being developed?</h2>
<p>Not at this time, but have a look at our <a href="../../contributing/html/index.html">Contributing page</a> for submitting back to the project.</p>
<hr/>
<h2><a class="anchor" id="7"></a> What platforms can I build and run VoltAir on?</h2>
<p>We've tested building VoltAir on Mac OS X and Ubuntu, targeted for running on Mac OS X, Ubuntu, and Android devices.</p>
<p>Theoretically, with a bit of work, other platforms could be supported through the cross-platform nature of Qt and Qt Creator.</p>
<hr/>
<h2><a class="anchor" id="8"></a>What versions of Android is VoltAir compatible with?</h2>
<p>VoltAir is known to run on Android 18+ and Android TV.</p>
<hr/>
<h2><a class="anchor" id="9"></a> What devices is VoltAir known to run on and why aren't more devices supported?</h2>
<p>VoltAir has been tested on Nexus 5, Nexus 7, Moto X by Motorola, Android TV, and some Samsung devices. Some devices are not supported because we did not optimize for all phones, and, as a result, the game would not perform well enough on them.</p>
<hr/>
<h2><a class="anchor" id="10"></a> Why did we choose to use C++?</h2>
<p>We chose to develop in C++ because it has better performance than Java, more directly integrates with LiquidFun, and is more familiar to the game developer community.</p>
<hr/>
<h2><a class="anchor" id="11"></a> Why did we choose to use Qt and what is QtQuick?</h2>
<p><a href="http://qt-project.org/doc/qt-5/qtquick-index.html">QtQuick</a> is one of the many frameworks provided by the <a href="http://qt-project.org/">Qt Project</a>. It is best described as a 2D scene graph with an accompanying renderer. You can build up a tree of items, each of which represents some aspect of the scene: graphics, physics, input, audio, data storage, etc. You can also define your own items by either subclassing <code>QQuickItem</code> (for items that have some graphical significance) or <code>QObject</code> (for items that are important for other uses). NOTE: <code>QQuickItem</code> is actually a subclass of <code>QObject</code>.</p>
<p>The QtQuick framework provides only a very shallow hierarchy of <code>QQuickItem</code> subclasses. Instead, the prescribed way to instantiate the objects is to write the graph in <em>QML</em>, a markup language in which you can describe hierarchies of <code>QQuickItem</code>s. Instead of providing a class hierarchy of <code>QQuickItem</code>s, Qt provides a hierarchy of QML <code>Item</code>s, of which there are hundreds. When you subclass from <code>QQuickItem</code>, you can register your class to become available in QML as well. You can also write a QML file that can then be instantiated as you would a single <code>Item</code>.</p>
<p>Due to time constraints, writing our own engine from the ground up wasn't really an option. We looked at various UI frameworks and game engines and decided Qt was not only the more daring choice due to the lack of games developed in it, but also a very interesting one due to the future ability to extend it into a rich editor, support from Digia, and many technical development advantages such as:</p><ul>
<li>Provided a platform abstraction that allowed us to also develop and test on desktop, reducing iteration time</li>
<li>Included a scene graph and out of the box "serialization" mechanism</li>
<li>Allowed for easily building a fluid UI system that was good for games</li>
<li>Provided an object model with dynamic JavaScript bindings, properties, as well as callback mechanisms for easy scripting and prototyping</li>
<li>Contained a well integrated IDE (<a href="http://qt-project.org/wiki/category:tools::qtcreator">QtCreator</a>)</li>
<li>Included a flexible <a href="http://qt-project.org/doc/qt-5/lgpl.html">LGPL License</a></li>
</ul>
<hr/>
<h2><a class="anchor" id="12"></a> What is the high-level design of VoltAir?</h2>
<h3>Game Design</h3>
<p>VoltAir is a fun, physics-based 2D adventure inspired by the mobile era zeitgeist, featuring a single-player campaign and a local multiplayer arena for up to 4 players, that works well on both mobile and Android TV devices. Below is a description of some of the aspects of the two modes of gameplay:</p><ul>
<li><p class="startli"><b>Single Player Campaign</b>:</p>
<p class="startli">In the single player campaign, players navigate a "robot" through multiple levels using rolling on a surface and "magnetizing" towards "meteors" to collect energy balls in their path. There are liquids flowing throughout the levels that create obstacles and puzzles.</p>
<p class="startli">For a gamepad, rolling is controlled via a left or right action on the joystick, dpad, or <code>L2/R2</code> triggers. Magnetism is controlled via the <code>A</code> button or <code>L1/R1</code> triggers. On other devices, such as keyboards or touch screens, these actions map to other logical inputs.</p>
<p class="startli">Once a player has collected enough energy, a portal at the end of the level will open allowing them to advance to the next level. Google Play Games Services achievements are awarded during gameplay based on energy collection, speed, and other creative conditions.</p>
<div class="image">
<img src="SinglePlayerScreenshot.png"  width="450" alt="Single Player Screenshot"/>
</div>
</li>
<li><p class="startli"><b>Multi Player Arena</b>:</p>
<p class="startli">In the multiplayer arena, up to 4 players compete on a single device, possibly using different controllers or splitting a single keyboard. A player simply joins the game by sending any event from a previously paired input device. Gameplay is very similar to single player, however the multiplayer arena differs by being a fixed space in which the characters move with no explicit puzzles to solve, but rather a goal of collecting as many energy snowflakes as possible. These snowflakes, while having similar energy properties to the orbs in single player, differ in that they can be magnetically attracted to robots that are magnetized, making them a dynamic element in the game.</p>
<p class="startli">In addition to the snowflakes being magnetic, players discover that robots, when magnetzied, also attract one another, and they can use this ability as a spoiler mechanic. The arena also features several bumpers and liquids that players can use to accelerate towards the snowflakes, which are constantly flowing from the top of the screen.</p>
<p class="startli">The player who collects a set number of snowflakes first is the winner.</p>
<div class="image">
<img src="MultiPlayerScreenshot.jpg"  width="450" alt="Multiplayer Screenshot"/>
</div>
</li>
</ul>
<h3>Software Design</h3>
<p>All aspects of VoltAir are defined by a hierarchy of QML <code>Item</code>s. There is both a static section of the scene graph hierarchy that always remains loaded and a dynamic section, which is loaded and unloaded during the course of the game, as seen below:</p>
<div class="image">
<img src="VoltAirSceneHierarchy.jpg"  width="640" alt="VoltAir Scene Hierarchy"/>
</div>
<p>What follows are the details about these various node types:</p>
<ul>
<li><p class="startli"><b>Root</b>:</p>
<p class="startli">The Root node is itself very lightweight and serves as the starting point for scene traversal. It has input and UI managers as well as the Camera as children.</p>
</li>
<li><p class="startli"><b>Camera</b>:</p>
<p class="startli">The <a href="../../API-Ref/html/classCamera.html">Camera</a> controls how everything below it is rendered. Its <code>lookAt</code> property determines where the camera points, and its <code>fov</code> property controls the zoom level. The <a href="../../API-Ref/html/classCamera.html">Camera</a> is able to deal with different aspect ratios as well as manage the parallax system which causes objects in different depth layers to move at different speeds, thereby creating the illusion of depth. The <a href="../../API-Ref/html/classCamera.html">Camera</a> also contains a logic for following one or more player characters in the level</p>
</li>
<li><p class="startli"><b>Level</b>:</p>
<p class="startli">The [Level][] is the representation of a single level during gameplay. It is the part that is dynamically loaded and unloaded as the player advances from one level to the next.</p>
</li>
<li><p class="startli"><b>Loader</b>:</p>
<p class="startli">The <code>Loader</code> is used to asynchronously load levels into the scene graph since calls to <code>QQmlComponent::create()</code> blocked the UI and rendering thread, making the game become unresponsive during loads. For more information, see our <a href="#24">workarounds section below</a>.</p>
</li>
<li><p class="startli"><b>Actor</b>:</p>
<p class="startli">Perhaps the most important item class we defined for VoltAir is the <a href="../../API-Ref/html/classActor.html">Actor</a>. It is the basic character unit for our game. The <a href="../../API-Ref/html/classActor.html">Actor</a> is a <code>QQuickItem</code> that holds onto the smaller building blocks of the game scene. Each <a href="../../API-Ref/html/classActor.html">Actor</a> has at least three classes of children:</p><ul>
<li><a href="../../API-Ref/html/classGraphic.html">Graphic</a>s, which are responsible for drawing</li>
<li><a href="../../API-Ref/html/classBody.html">Body</a>, which is the physical representation of the actor</li>
<li><a href="../../API-Ref/html/classLogic.html">Logic</a>s, which are responsible for computation that is not performed by the physics</li>
</ul>
</li>
<li><p class="startli"><b>InputArea</b>:</p>
<p class="startli">The <a href="../../API-Ref/html/classInputArea.html">InputArea</a> is a module for gaining basic input event (i.e. keyboard) support on non-Android devices. See the details of <a href="#13">GameInput</a> below for more information.</p>
</li>
<li><p class="startli"><b>Ui</b>:</p>
<p class="startli">The <a href="../../API-Ref/html/classUi.html">Ui</a> serves as a manager for all possible viewing states of the games overlay UI, including menus, splash or loading screens, and heads-up display (hud) information.</p>
</li>
</ul>
<p>The following diagram shows the layout of the main character in VoltAir, the <a href="../../API-Ref/html/classRobot.html">Robot</a>. We see its graphics have many states that can be animated (e.g. its magnetism's visibility can change, its eyes can move, etc.). The <a href="../../API-Ref/html/classBody.html">Body</a> is a circle so it can roll. Its logics handle behavioral aspects such as its rolling, player-input directed forces, etc.</p>
<div class="image">
<img src="RobotBreakdown.jpg"  width="500" alt="Robot Actor Breakdown"/>
</div>
<p>As we see, an <a href="../../API-Ref/html/classActor.html">Actor</a>'s subobjects are both <code>QQuickItem</code>s and <code>QObject</code>s. This table shows more explicitly which are of which subclass (note how only objects involved in graphics traversal are <code>QQuickItem</code>s) and specific examples of their use in the game:</p>
<table class="doxtable">
<tr>
<th>Class </th><th>Inherits from </th><th>Description </th><th>Examples  </th></tr>
<tr>
<td><a href="../../API-Ref/html/classActor.html">Actor</a> </td><td><code>QQuickItem</code> </td><td>Top-level element in the game. May contain visuals, a physics body, and behavioral logics, defining the <b>composition</b> and configuration of its elements. </td><td><a href="../../API-Ref/html/classRobot.html">Robot</a>, <a href="../../API-Ref/html/classPortal.html">Portal</a>, <a href="../../API-Ref/html/classOrb.html">Orb</a>, <a href="../../API-Ref/html/classParticleEmitter.html">ParticleEmitter</a> </td></tr>
<tr>
<td><a href="../../API-Ref/html/classGraphic.html">Graphic</a> </td><td><code>QQuickItem</code> </td><td><code>Image</code>s or <a href="../../API-Ref/html/classRenderer.html">Renderer</a>s defining the <b>look</b> of the <a href="../../API-Ref/html/classActor.html">Actor</a>. </td><td><a href="../../API-Ref/html/classImageRenderer.html">ImageRenderer</a>, <a href="../../API-Ref/html/classTerrainMeshRenderer.html">TerrainMeshRenderer</a> </td></tr>
<tr>
<td><a href="../../API-Ref/html/classBody.html">Body</a> </td><td><code>QObject</code> </td><td>Defines the <b>physical body</b> of an <a href="../../API-Ref/html/classActor.html">Actor</a>, wraps Box2D body. </td><td><a href="../../API-Ref/html/classCircleBody.html">CircleBody</a>, <a href="../../API-Ref/html/classPolygonBody.html">PolygonBody</a> </td></tr>
<tr>
<td><a href="../../API-Ref/html/classLogic.html">Logic</a> </td><td><code>QObject</code> </td><td>Logical <b>behavior</b> of the <a href="../../API-Ref/html/classActor.html">Actor</a>, evaluated every frame. </td><td><a href="../../API-Ref/html/classRollingMovementLogic.html">RollingMovementLogic</a>, <a href="../../API-Ref/html/classParticleEmitterLogic.html">ParticleEmitterLogic</a> </td></tr>
</table>
<hr/>
<h2><a class="anchor" id="13"></a> What is GameInput, why did you build it, and how do you use it?</h2>
<h3>Motivation</h3>
<p>To achieve support for different "controller" types (i.e. input devices which could logically be used to control the robot character) and multiple input sources, we implemented a separate input layer abstraction, <a href="../../API-Ref/html/group__GameInput.html">GameInput</a>, that could be re-used for handling controller input in a variety of controller-based applications.</p>
<p>The need for such a system arose with the realization that Qt's event system based around <code>QEvent</code> did not support all desired controller types, nor did it support differentiation of input sources. Specifically, there does not currently exist a subclass of <code>QEvent</code> capable of representing real-valued axis events, and, instead, Qt's platform-dependent input handling delegates convert such input into <code>QKeyEvent</code>s (e.g. on Android, holding right on a thumbstick would generate a "right" key event). Furthermore, <code>QEvent</code> lacks the fundamental concept of device ID, meaning all identical input events on different controllers are indistinguishable from one another, which would prevent local multiplayer support.</p>
<h3>Goals</h3>
<ul>
<li>Support keyboard, gamepad, and touch navigation input devices as controllers on Android</li>
<li>Minimally support keyboard for input on all non-Android platforms</li>
<li>Support mapping unique input devices to unique players</li>
<li>Support non-1:1 mappings (i.e. splitting) of input devices to players (e.g. left-half of keyboard vs. right-half of keyboard as different players)</li>
<li>Re-usable module for use in other controller-based applications with no VoltAir-specific logic tied into it</li>
<li>Easily extensible to other controller "types"</li>
</ul>
<h3>Non-goals</h3>
<ul>
<li>Have parity on all platforms for input support</li>
<li>Extension of Qt's pre-existing <code>QEvent</code> system</li>
<li>Support asynchronous input event game models (i.e. responding to input events immediately at their time of occurrence)</li>
</ul>
<h3>Overview</h3>
<p>To that end, the GameInput library contains three major components:</p><ul>
<li><p class="startli"><b>GameInput Static Library</b>:</p>
<p class="startli">Main, platform-independent module that defines logic for handling of input events, storing controller state, and defining controller input schemes.</p>
</li>
<li><p class="startli"><b>Device Shim Layer</b></p>
<p class="startli">Intermediate, platform-dependent module for converting device-specific events into general platform-independent <a href="../../API-Ref/html/classControllerEvent.html">ControllerEvent</a>s and routing them to the appropriate <a href="../../API-Ref/html/classInputRouter.html">InputRouter</a>.</p>
</li>
<li><p class="startli"><b>Game-Specific Client</b></p>
<p class="startli">Application-dependent code that establishes how <a href="../../API-Ref/html/classVirtualController.html">VirtualController</a>s are mapped to players, defines the canonical set of schemes mapping inputs to actions, and provides mechanisms for querying of the state of particular player actions.</p>
</li>
</ul>
<div class="image">
<img src="GameInputDesign.jpg"  width="640" alt="GameInput Module"/>
</div>
<h3>Module Classes</h3>
<table class="doxtable">
<tr>
<th>GameInput Library Class </th><th>Description  </th></tr>
<tr>
<td><a href="../../API-Ref/html/classControllerEvent.html">ControllerEvent</a> </td><td>A platform-independent event capable of representing input generated by any type of controller. </td></tr>
<tr>
<td><a href="../../API-Ref/html/classVirtualController.html">VirtualController</a> </td><td>A representation of a physically-based controller (or part of one) with a unique device ID, 0 or 1 of each type of <a href="../../API-Ref/html/classInputScheme.html">InputScheme</a>, input capabilities that can be described by a <a href="../../API-Ref/html/classControllerEvent.html">ControllerEvent</a>, support for handling events marked with the same device ID, storage of current state, and an ability to be queried current action value depending upon support (binary, unit value, symmetric unit value) for those actions. </td></tr>
<tr>
<td><a href="../../API-Ref/html/classInputScheme.html">InputScheme</a> </td><td>A mapping from generic input "events" (e.g. key codes or trigger axes) to output "actions". </td></tr>
<tr>
<td><a href="../../API-Ref/html/classControllerFactory.html">ControllerFactory</a> </td><td>Interface for constructing <a href="../../API-Ref/html/classVirtualController.html">VirtualController</a>s from a device ID. Factories encapsulate component <a href="../../API-Ref/html/classInputScheme.html">InputScheme</a>s that comprise a <a href="../../API-Ref/html/classVirtualController.html">VirtualController</a> and implicitly define controller "types" in the process. For example, the <a href="../../API-Ref/html/classGamepadRouter_1_1GamepadControllerFactory.html">GamepadControllerFactory</a> creates gamepad-related <a href="../../API-Ref/html/classVirtualController.html">VirtualController</a>s with a specified <a href="../../API-Ref/html/classKeyScheme.html">KeyScheme</a>, <a href="../../API-Ref/html/classJoystickAxisScheme.html">JoystickAxisScheme</a>, and <a href="../../API-Ref/html/classTriggerAxisScheme.html">TriggerAxisScheme</a>. </td></tr>
<tr>
<td><a href="../../API-Ref/html/classInputRouter.html">InputRouter</a> </td><td>Routes <a href="../../API-Ref/html/classControllerEvent.html">ControllerEvent</a>s according to inherent ControllerFactory specifications. Specifically, the router creates an additional abstraction layer onto physical device IDs, allowing one physical device to be split into multiple <a href="../../API-Ref/html/classVirtualController.html">VirtualController</a>s via different <a href="../../API-Ref/html/classControllerFactory.html">ControllerFactory</a>s that contain non-intersecting input schemes. As a result, the "type" of InputRouter is defined implicitly by the <a href="../../API-Ref/html/classControllerFactory.html">ControllerFactory</a>s that comprise it (e.g. <a href="../../API-Ref/html/classGamepadRouter.html">GamepadRouter</a> uses <a href="../../API-Ref/html/classGamepadRouter_1_1GamepadControllerFactory.html">GamepadControllerFactory</a>s). </td></tr>
<tr>
<td><a href="../../API-Ref/html/classControllerManager.html">ControllerManager</a> </td><td>Manager to maintain a global list of connected controllers and notify registered listeners of changes in these connection statuses. </td></tr>
</table>
<p><br />
</p>
<table class="doxtable">
<tr>
<th>Device Shim Layer Class </th><th>Description  </th></tr>
<tr>
<td><a href="../../API-Ref/html/classVoltAirActivity.html">VoltAirActivity</a> / <a href="../../API-Ref/html/classAndroidActivity.html">AndroidActivity</a> </td><td>Intercepts Android-specific input events (<code>KeyEvent</code>s and <code>MotionEvent</code>s) and converts them (via JNI) into <a href="../../API-Ref/html/classControllerEvent.html">ControllerEvent</a>s that are routed to the appropriate <a href="../../API-Ref/html/classInputRouter.html">InputRouter</a> according to Android-defined input sources (e.g. keyboard vs. gamepad vs. touch navigation). </td></tr>
<tr>
<td><a href="../../API-Ref/html/classInputArea.html">InputArea</a> </td><td>Intercepts Qt key input events (<code>QKeyEvent</code>s) on non-Android platforms and converts them into <a href="../../API-Ref/html/classControllerEvent.html">ControllerEvent</a>s that are routed to the <a href="../../API-Ref/html/classKeyboardRouter.html">KeyboardRouter</a>. </td></tr>
</table>
<p><br />
</p>
<table class="doxtable">
<tr>
<th>Game-specific Class </th><th>Description  </th></tr>
<tr>
<td><a href="../../API-Ref/html/classPlayerManager.html">PlayerManager</a> </td><td>Manager that establishes a mapping from unique player identifiers to different <a href="../../API-Ref/html/classVirtualController.html">VirtualController</a>s that connect and disconnect throughout the game. Additionally, the manager abstracts away the different controller capabilities (i.e. different combinations of action support), instead defining and allowing the simple querying of relevant player values (e.g. horizontal motion or magnetized) through special methods. </td></tr>
<tr>
<td><a href="../../API-Ref/html/classGameInputLogic.html">GameInputLogic</a> </td><td>Behavior that synchronously updates its parent <a href="../../API-Ref/html/classActor.html">Actor</a>'s player-related properties (e.g. horizontal input force and magnetized) each frame by polling the <a href="../../API-Ref/html/classPlayerManager.html">PlayerManager</a>'s reported state for the actor's player ID. </td></tr>
</table>
<h3>Example Input Event Data Flow</h3>
<p>To better elucidate the operation and usage of the GameInput library, consider the following sequence of events which occur in the first time the VoltAir application receives a <code>KeyEvent</code> on Android for the left arrow key:</p><ol type="1">
<li><a href="../../API-Ref/html/classVoltAirActivity.html">VoltAirActivity</a> intercepts the <code>KeyEvent</code> in <code>dispatchKeyEvent()</code>.</li>
<li><a href="../../API-Ref/html/classAndroidActivity.html">AndroidActivity</a> receives the <code>KeyEvent</code> via a native callback.</li>
<li><a href="../../API-Ref/html/classAndroidActivity.html">AndroidActivity</a> converts the <code>KeyEvent</code> into an associated <a href="../../API-Ref/html/classControllerEvent.html">ControllerEvent</a>, maintaining the original device ID, and passes it off to the <a href="../../API-Ref/html/classKeyboardRouter.html">KeyboardRouter</a> for handling.</li>
<li><a href="../../API-Ref/html/classKeyboardRouter.html">KeyboardRouter</a>, having been initialized with a <a href="../../API-Ref/html/classKeyboardRouter_1_1KeyboardControllerFactory.html">KeyboardControllerFactory</a> whose <a href="../../API-Ref/html/classKeyScheme.html">KeyScheme</a> mapped a left arrow key code to the "left" action, accepts the event for routing.</li>
<li><a href="../../API-Ref/html/classKeyboardRouter.html">KeyboardRouter</a> then rewrites the <a href="../../API-Ref/html/classControllerEvent.html">ControllerEvent</a>'s device ID with a unique, fake device ID, and remembers the fake device ID used for the real deviceID and the matching <a href="../../API-Ref/html/classKeyboardRouter_1_1KeyboardControllerFactory.html">KeyboardControllerFactory</a>. Thus, in the future, <code>UP-DOWN-RIGHT</code> events from this keyboard can be mapped to the same <a href="../../API-Ref/html/classVirtualController.html">VirtualController</a>, but <code>UP-DOWN-RIGHT</code> events from another keyboard ord <code>A-S-D</code> events from the same keyboard can both be mapped to different <a href="../../API-Ref/html/classVirtualController.html">VirtualController</a>s.</li>
<li><a href="../../API-Ref/html/classKeyboardRouter.html">KeyboardRouter</a> then requests a <a href="../../API-Ref/html/classVirtualController.html">VirtualController</a> with the relevant fake device ID from the <a href="../../API-Ref/html/classControllerManager.html">ControllerManager</a>, providing the manager with a reference to the matching <a href="../../API-Ref/html/classKeyboardRouter_1_1KeyboardControllerFactory.html">KeyboardControllerFactory</a>.</li>
<li>Having never seen the provided device ID before, the <a href="../../API-Ref/html/classControllerManager.html">ControllerManager</a> uses the provided factory to construct a new keyboard-related <a href="../../API-Ref/html/classVirtualController.html">VirtualController</a> and return a reference to it, but not before notifying all listeners that a controller with the fake device ID has connected.</li>
<li><a href="../../API-Ref/html/classPlayerManager.html">PlayerManager</a> receives the connection notification and maps this fake device ID to the first available player ID.</li>
<li><a href="../../API-Ref/html/classKeyboardRouter.html">KeyboardRouter</a>, now having a reference to a <a href="../../API-Ref/html/classVirtualController.html">VirtualController</a>, simply routes the <a href="../../API-Ref/html/classControllerEvent.html">ControllerEvent</a> to it, causing it to update its internal state appropriate according to the <a href="../../API-Ref/html/classKeyScheme.html">KeyScheme</a> from which it was constructed. This state can then be queried through methods defined in <a href="../../API-Ref/html/classPlayerManager.html">PlayerManager</a> for the appropriate player ID.</li>
</ol>
<hr/>
<h2><a class="anchor" id="14"></a> What is the VoltAir Renderer and what are some tricks behind the visuals?</h2>
<h3>Motivation</h3>
<p>To achieve high enough performance in rendering of our game's scene (i.e. <a href="../../API-Ref/html/classActor.html">Actor</a>s such as terrain pieces, characters, and collectables), we implemented VoltAir's <a href="../../API-Ref/html/group__Renderer.html">game-specific renderer</a>, a simple 2D scene, OpenGL renderer, and use QtQuick's renderer exclusively for the UI.</p>
<p>The main objective for this renderer is simplicity, as our initial investigations indicated our target devices can achieve sufficient fill rate to render scenes of our game's complexity, even with naive draw calls and structure. Much of QtQuick's slowness appears to instead be caused by significant CPU overhead processing geometry (e.g. to merge vertex batches) and the use of synchronous GL driver calls. The performance hit from this overhead is compounded by the fact that we use fluid simulations, which are also CPU heavy.</p>
<h3>Goals</h3>
<ul>
<li>Support rendering 2D scenes of simple to medium complexity</li>
<li>Provide a low CPU overhead renderer implementation which is malleable and reusable</li>
<li>Provide reusable independent parts that can be used in other renderers</li>
<li>Allow quick prototyping of new games</li>
<li>Integratable with other renderers like Qt's QQuick renderer, with support for custom GL calls for specialized effects</li>
</ul>
<h3>Non-goals</h3>
<ul>
<li>Provide batching or other optimizations</li>
<li>Provide text rendering or other UI features</li>
<li>Allow seamless mixing of UI-like components within the scene</li>
<li>To provide engine-like features such as animation, tweening, touch / pointer event delegation</li>
</ul>
<h3>Overview</h3>
<p>The renderer is composed of three main components, seen below:</p>
<div class="image">
<img src="RendererDesign.jpg"  width="640" alt="Renderer"/>
</div>
<h3>Techniques</h3>
<p>One of the techniques we used to render the world was our terrain shader. This draws many of the larger pieces of ground and terrain throughout the game. To minimize the number of unique textures we had to create, it uses multi-texture blends to create variation, using up to three textures at a time. The geometry and texture coordinates for the terrain were precomputed based on the terrain's physical collision mesh (by our in-house level editor).</p>
<p>Another technique we used was our LiquidFun fluid renderer. This takes the discrete particles that form the fluid simulation, and visualizes them as roughly blob-shaped entities. Several effects are applied on top of this:</p><ul>
<li>A highlight effect</li>
<li>A fake specular lighting effect</li>
<li>An inner shadow effect</li>
</ul>
<p>These effects were chosen to help the particles blend in with the game world.</p>
<hr/>
<h2><a class="anchor" id="15"></a> What is the VoltAir Engine, and is it really a game engine?</h2>
<p>As we developed the code, we made an effort to separate out the code that was not specific to the VoltAir game itself. This code is found in the <code>Engine</code> directory. For instance, <a href="../../API-Ref/html/classCamera.html">Camera</a>, <a href="../../API-Ref/html/classActor.html">Actor</a>, <a href="../../API-Ref/html/classBody.html">Body</a>, <a href="../../API-Ref/html/classLogic.html">Logic</a>, etc. are all defined in <code>Engine</code>, as is the <a href="../../API-Ref/html/classmain.html">main QML item</a> for the game. By contrast, items and classes such as <a href="../../API-Ref/html/classAsteroid.html">Asteroid</a>, <a href="../../API-Ref/html/classOrb.html">Orb</a>, <a href="../../API-Ref/html/classSnowflake.html">Snowflake</a>, and <a href="../../API-Ref/html/classUi.html">Ui</a> are defined elsewhere, as these are objects unique to VoltAir-specific.</p>
<p>The <a href="../../API-Ref/html/group__Engine.html">VoltAir Engine</a> can be thought of as a game engine in that it provides an infrastructure for building at least a certain class of games. A full game engine, however, is more robust than what the VoltAir Engine provides. One can consider it an engine only to the extent that its engine qualities can be factored out and used for games other than VoltAir. If one were to do this, though, they may quickly run into its limitations and find that additional functionality would need to be added.</p>
<hr/>
<h2><a class="anchor" id="16"></a> Why is there all this JavaScript?</h2>
<p>JavaScript is supported out of the box by Qt through QtQuick and QML. While not required, using JavaScript expressions and blocks of functionality allowed for quick prototyping of our <a href="../../API-Ref/html/classActor.html">Actor</a>s because we could leverage dynamic properties and code to reduce compilation time with lower overhead and verbosity. The end result allowed our levels and game logic to be more data driven, which we consider a success. While the JavaScript is less performant than the corresponding C++ logic in most scenarios, we did not find this to be overly prohibitive, especially when prototyping.</p>
<hr/>
<h2><a class="anchor" id="17"></a> How did you design the UI?</h2>
<p>QtQuick's strongest feature by far is its abstraction for building user interfaces. It is, in fact, very well suited for the types of UIs you would expect in a game, where there is a lot of latitude taken in the UI element design and animations are abundant. Given this, there is very little novel about VoltAir's UI. We did build two important UI elements that were used extensively, and hence noteworthy:</p><ul>
<li><p class="startli"><a href="../../API-Ref/html/classUiComponent.html">UiComponent</a>:</p>
<p class="startli">This is the top level "page" in the UI. All UI elements animate on and off of the display. This base component provides what is effectively an abstract API for this showing and hiding, as well as for managing input focus.</p>
</li>
<li><p class="startli"><a href="../../API-Ref/html/classKeyNavFocusArea.html">KeyNavFocusArea</a>:</p>
<p class="startli">This is an extension of the standard QML <code>FocusScope</code> that maintains and forwards focus intended specifically to support UI navigation using <code>UP/DOWN/LEFT/RIGHT</code> keys (or their equivalents). For each <a href="../../API-Ref/html/classKeyNavFocusArea.html">KeyNavFocusArea</a>, you can define which other <code>Item</code> grabs focus when one of these keys is hit. Explained in terms of AndroidTV, this provides the creation of basic "Pano" navigation.</p>
</li>
</ul>
<hr/>
<h2><a class="anchor" id="18"></a> If I want to develop my own new application based on the VoltAir source code, where do I start?</h2>
<p>The basic idea to build a new game based on this source is to incrementally transform the current code base into your own game. The following is not a complete list, but is at least a starting point for interested developers:</p>
<ul>
<li>Deep copy the entire repo.</li>
<li>Rename the <code>VoltAir</code> directory and the <code>VoltAir.pro</code> file to reflect the name of your new game.</li>
<li>Navigate into the <code>Engine</code> directory and perform a recursive, case-insensitive search for "voltair" to lead you to places where names must be changed.</li>
<li>Familiarize yourself with the QML-defined actors in <code>VoltAir/qml/actors</code>.<ul>
<li>Notice how they each have <a href="../../API-Ref/html/classBody.html">Body</a> items that define their physics behavior and <a href="../../API-Ref/html/classLogic.html">Logic</a> items that implement other behaviors.</li>
<li>Pay close attention to the <a href="../../API-Ref/html/classRobot.html">Robot</a> actor and how data is passed from its <a href="../../API-Ref/html/classGameInputLogic.html">GameInputLogic</a> item (via <code>inputForce</code>) to its <a href="../../API-Ref/html/classJavaScriptLogic.html">JavaScriptLogic</a> item which consumes the data. This is how user input affects the world.</li>
</ul>
</li>
<li>Familiarize yourself with the QML-defined levels in <code>VoltAir/assets/levels</code>. Note how they instantiate the actors you learned of earlier.</li>
<li>Mimic the actors and levels to define your game. Swap out VoltAir's levels for your own in <code>VoltAir/qml/VoltAirLevelProgressionList.qml</code>.</li>
<li>Once this is working, go back and rewrite the <a href="../../API-Ref/html/classUi.html">Ui</a> item to use your own game's user interface.</li>
<li>If you plan on deploying Google Analytics or Play Games Services, you will have to replace VoltAir's definitions, found here:<ul>
<li><code>VoltAir/Engine/android/deploy/res/xml/voltair_tracker.xml</code>: Analytics tracking ID.</li>
<li><code>VoltAir/Engine/android/deploy/res/values/ids.xml</code>: Play Games Services Achievement IDs.</li>
</ul>
</li>
</ul>
<hr/>
<h2><a class="anchor" id="19"></a> How did you integrate Box2D / LiquidFun?</h2>
<p>Box2D and LiquidFun form the backbone of our game's physics. Each actor can have a physics body, which translates to a Box2D rigid body with fixtures. We have synchronization phases before and after stepping the Box2D world to keep things in lock-step. The same is true for LiquidFun. Particles are owned by emitters, and are synchronized at discrete points. For more information, see our wrapper <a href="../../API-Ref/html/classBody.html">Body</a>, <a href="../../API-Ref/html/classJoints.html">Joints</a>, and <a href="../../API-Ref/html/classParticle.html">Particle</a> wrapper classes.</p>
<p>To visualize these physics shapes, actors have associated graphics. These graphics, which can be anything from simple sprites to terrain pieces rendered using our terrain shader, are synchronized to their physics bodies by their actors during the synchronization phase. Particles on the otherhand are rendered all together using a single shader effect (with multiple passes).</p>
<hr/>
<h2><a class="anchor" id="20"></a> How could I use the different particle types in LiquidFun and what other additional features could I add to VoltAir?</h2>
<p>VoltAir only uses normal fluid particles. However, LiquidFun also supports rigid, elastic, powder, spring, tensile, and wall particles. Different ways to interact with the environment could come from experimenting with these different particle types. See the <a href="https://google.github.io/liquidfun/">LiquidFun documentation</a> for more information on how to use them.</p>
<p>Exciting gameplay could also emerge from making magnetic actors that repel instead of attract. Or, instead of magnetism powers, give the robot a water powered jetpack to zoom around the level!</p>
<p>Consider adding a second player to the single player campaign. Alternatively, give multiple players control of different parts of the robot and work together to finish the game!</p>
<p>Try scripting and adding new <a href="../../API-Ref/html/classActor.html">Actor</a> types and throwing them into the levels.</p>
<p>The possibilities for this type of platformer are nearly endless!</p>
<hr/>
<h2><a class="anchor" id="21"></a> Where is the level editor?</h2>
<p>Our level editor was developed in Java and represents a separate, incompatible runtime.</p>
<p>As a result, we chose not to release it because of the added additional complexity to the open-source project (i.e. we could not provide a high enough standard to release and support it).</p>
<hr/>
<h2><a class="anchor" id="22"></a> Why aren't you using the Play Games Services C++ SDK?</h2>
<p>Google Play Games Native SDK can be found <a href="https://developers.google.com/games/services/cpp/GettingStartedNativeClient">here</a>.</p>
<p>The API was not released in time for us to integrate it into VoltAir. Additionally, while in beta, the C++ SDK did not support cloud save.</p>
<p>Instead, we decided to integrate Play Games Services and Analytics natively through our own custom JNI wrapper. Take a look at the code in <a href="../../API-Ref/html/classAndroidActivity.html">AndroidActivity</a> and <a href="../../API-Ref/html/classSelfDetachingJNIEnv.html">SelfDetachingJNIEnv</a> for examples and reusable boilerplate code of wrapping functionality that exists in Java and using it natively.</p>
<hr/>
<h2><a class="anchor" id="23"></a> What's the deal with the sound files in the open source code?</h2>
<p>Some of the sound files released in production are individually licensed to Google and could not be made open source. We replaced these sound effects with placeholder sounds in the open source code.</p>
<hr/>
<h2><a class="anchor" id="24"></a> What workarounds did you need to implement?</h2>
<p>In the process of implementing VoltAir on top of the QtQuick framework, we discovered a series of unrelated issues that needed to be worked around in order to make it viable as a game platform.</p>
<p>We list here some of the workarounds or issues we found interesting and hope they individually can be extracted for some value:</p><ul>
<li><p class="startli"><b>Lack of support for controller events with device ids and axis values</b></p>
<p class="startli">See <a href="#13">GameInput</a> for more information.</p>
</li>
<li><p class="startli"><b>Need for a low-CPU overhead renderer for game elements</b></p>
<p class="startli">Out of the box, the performance of the <code>QSGBatchRenderer</code> for rendering large scenes was bottlenecking our CPU usage, and so we decided to write our own custom game renderer. See <a href="#14">VoltAir Renderer</a> for more information.</p>
</li>
<li><p class="startli"><b>No RGB 565 formats on Android</b></p>
<p class="startli">Due to a known issue, we were restricted to 32 bit formats, which led to lower GPU performance.</p>
</li>
<li><p class="startli"><b>Handling Android lifecycle events within Qt</b></p>
<p class="startli">Qt continued renderering even when the app was backgrounded, causing errors in addition to battery performance issues. First, in order to respond to lifecycle events appropriately, we needed to install native callbacks (see <a href="../../API-Ref/html/classAndroidActivity.html">AndroidActivity</a>). Second, in the event that the application became backgrounded, we forced rendering to stop by hiding the <code>QQuickView</code> appropriately and informed all <code>QQuickItem</code>s in the UI of the device pause event.</p>
</li>
<li><p class="startli"><b>JavaScript performance</b></p>
<p class="startli">Many of our actors and behaviors were initially scripted using JavaScript. While this was advantageous for quick prototyping and adding of new features, it soon became a CPU bottleneck. As a result, we ported several of our core <a href="../../API-Ref/html/classLogic.html">Logic</a>s to native implementations.</p>
</li>
<li><p class="startli"><b><code>QQmlComponent::create()</code> blocks the UI thread</b></p>
<p class="startli">Initially, we created our levels directly from QML data, using <code>QQmlComponent</code> to instantiate the level. However, this method resulted in a large blocking function call as QML data was parsed, objects were instantiated and initialized, and textures were loaded. Furthermore, since the rendering thread is synchronized in lock step with the UI thread, no animations could be played while the UI thread remained blocked, and thus the UI became unresponsive during even the smallest level loads.</p>
<p class="startli">We enabled asynchronous loading of levels by using a <code>Loader</code> component in the QML scene graph, but this brought about additional issues. Most importantly, a bug in the loader sometimes causes an incorrect past level to be loaded, seemingly from data previously cached. The cached data causes our memory footprint to rise dramatically with each new level loaded, even after deleting the previous level, and possibly longer load times as we must try reloading until the desired level is finally initialized.</p>
</li>
<li><p class="startli"><b>High level load times when deserializing mesh vertex attribute data</b></p>
<p class="startli">Originally, we initialized our mesh vertex attribute data using explicitly written arrays of floats in QML, however, such an approach required excessive <code>QVariant</code> creation and copying, as well as significantly more text processing, during level load and initialization.</p>
<p class="startli">Consequently, we switched over to encoding these large list of floats directly as binary data in base64, slashing our load times but reducing clarity in our level data files.</p>
</li>
<li><p class="startli"><b>Gapless looping of audio</b></p>
<p class="startli">The default implementation of the <code>QMediaPlayer</code>, while supporting looping, includes noticeable gaps during playback. This was addressed for Android devices by using JNI to instantiate and play a Java-based Android <a href="http://developer.android.com/reference/android/media/MediaPlayer.html">MediaPlayer</a>, which itself required double buffering tricks to correctly get gapless playback. See <a href="../../API-Ref/html/classcom_1_1google_1_1fpl_1_1utils_1_1SoundManager.html">SoundManager</a> for more details.</p>
</li>
<li><p class="startli"><b><code>QSoundEffect</code> has different performance on Mac for mono vs. stereo</b></p>
<p class="startli">There are severe performance issues, even when caching the sound effect data, using mono WAV files for the sound effects on Mac instead of stereo. Hiccups in gameplay will be noticed on Mac as a result. We recommend using stereo sound effects when testing on Mac until the issue is resolved.</p>
</li>
<li><p class="startli"><b>Lists in QML</b></p>
<p class="startli"><code>QList</code>s defined in C++ cannot be exposed to or modified from QML. In order to enable this, one must use the <code>QQmlListProperty</code> type, but it is cumbersome for typical use in C++. Since lists are a common data structure primitive used in games, we provide a utility class <a href="../../API-Ref/html/classUtil_1_1QQmlListPropertyOnQList.html">QQmlListPropertyOnQList</a> to simplify exposing a <code>QQmlListProperty</code> backed by a <code>QList</code>.</p>
</li>
<li><p class="startli"><b>"Polymorphic types" in QML / C+</b></p>
<p class="startli">Although, as our design above indicates, each <a href="../../API-Ref/html/classActor.html">Actor</a> has a <a href="../../API-Ref/html/classBody.html">Body</a> property that is optionally filled, our API does not explicitly declare such a property. This is because explicitly declaring the property as type <a href="../../API-Ref/html/classBody.html">Body</a> either in C++ or in QML restricts usage of properties or functions on the type to those in the <a href="../../API-Ref/html/classBody.html">Body</a> base class, even in QML or JavaScript, which are not as strongly-typed. For example, <a href="../../API-Ref/html/classPolygon.html">Polygon</a> actors would not be able to access <code>body.vertices</code> even if the <code>body</code> property had been set to use a <a href="../../API-Ref/html/classPolygonBody.html">PolygonBody</a>.</p>
<p class="startli">To address this, we have adopted a convention that each <a href="../../API-Ref/html/classActor.html">Actor</a> when defined in QML declare <code>property alias body</code> so that <code>body</code> can be dynamically typed to the type of <a href="../../API-Ref/html/classBody.html">Body</a> used by that <a href="../../API-Ref/html/classActor.html">Actor</a>.</p>
</li>
<li><p class="startli"><b>Permissions in Android</b></p>
<p class="startli">By default, the <code>AndroidManifest.xml</code> generated by Qt leaves a replaceable macro <code>%%INSERT_PERMISSIONS%%</code> in order to dynamically insert relevant permissions needed by the application depending upon the set of Qt modules used. However, due to the broad functional nature of some of the modules, in particular <code>multimedia</code>, this led to VoltAir requesting permissions it did not need. To reduce user confusion, and keep permissions restricted to the narrowest, workable set, we removed this tag from the manifest and manually added back in the required permissions.</p>
<p class="startli">As a result, one must be careful when using functionality that is already included in the Qt libraries used with VoltAir but for which our manifest may now lack the relevant permission (e.g. recording audio through <code>QtMultimedia</code>).</p>
</li>
<li><p class="startli"><b>QML Animations and Timers are built on wallclock time</b></p>
<p class="startli">There are several animated elements or sequences that can occur during VoltAir gameplay. However, using QML animation groups and timers to accomplish these effects results in the animated elements possibly running at a different rate from the game and, more importantly, makes them difficult to pause and resume along with the game.</p>
<p class="startli">We address this by introducing the concept of "game time", advanced by each rendered frame of unpaused VoltAir gameplay, and by providing helpful primitives for using it in <a href="../../API-Ref/html/classStopwatchLogic.html">StopwatchLogic</a> and <a href="../../API-Ref/html/classAnimatedImageRenderer.html">AnimatedImageRenderer</a>'s <code>useGameTime</code> property.</p>
</li>
<li><p class="startli"><b>QML Item <code>transitions</code> can be interrupted</b></p>
<p class="startli"><code>Transition</code> animation groups written as part of an <code>Item</code>'s <code>transitions</code> can be interrupted and stopped before completion if another transition occurs, rather than being completed in sequence or parallel with the newly triggered <code>Transition</code>. Specifically, if we have defined a transition from state <code>A</code> to state <code>B</code> and a transition from state <code>B</code> to state <code>C</code>, then the animations as part of the first <code>Transition</code> animation group will be triggered when the <code>Item</code> moves from state <code>A</code> to state <code>B</code>, however, if <code>state</code> is changed to <code>C</code> before this first animation group has completed, it will be preempted in favor of the second transition group.</p>
<p class="startli">As a result, this can leave <code>Item</code>s in odd, incompletely transitioned states &ndash; especially in the UI layer when transitions are often a function of user input.</p>
<p class="startli">To combat this, we made our transition animation groups contain only relatively simple and quick function calls that kicked off "background" transition animations on other <code>Item</code>s that would not be interrupted. More specifically, we introduced the fundamental UI building block in the <a href="../../API-Ref/html/classUiComponent.html">UiComponent</a> which can show or hide itself, reducing pressure on <a href="../../API-Ref/html/classUi.html">Ui</a>, the main manager of all possible UI viewing states, getting stuck in an intermediate state due to responding to user input.</p>
</li>
<li><p class="startli"><b>Why we need <code>Renderer::addCompatibilityPrefixToShaderCode</code></b></p>
<p class="startli">Our custom game renderer needed to be compatible with both desktop and mobile clients, however, not all GPU architectures or desktop OpenGL versus mobile OpenGLES supported the same set of precision modifiers, requiring a compatibility prefix to share shader code between the platforms.</p>
</li>
<li><p class="startli"><b>QML <code>Image</code> does not cache textures</b></p>
<p class="startli">Once no <code>Image</code>s reference a particular <code>source</code>, the backing texture is freed. However, in VoltAir, these textures may get loaded again only moments later. For improved performance, we implemented a <a href="../../API-Ref/html/classTextureManager.html">TextureManager</a> as part of the VoltAir renderer for caching these textures.</p>
</li>
<li><p class="startli"><b>GL resources continue to be accessed by graphics pipeline after level deletion</b></p>
<p class="startli">Since rendering occurs in a separate thread, GL resources like textures and vertex buffers must continue to be valid while the GPU is accessing them (i.e. until they have been flushed from the pipeline, for example through a call to <code>glSwapBuffer</code>), even after the level has been deleted. As a result, we must delay unloading of GL resources by a couple of frames.</p>
</li>
<li><p class="startli"><b>Initialization ordering issues</b></p>
<p class="startli">The UI, upon creation, needs to access managers, like <a href="../../API-Ref/html/classTextureManager.html">TextureManager</a>, which has yet to be created and initialized. As a result, we delayed creation of the <a href="../../API-Ref/html/classUi.html">Ui</a> <code>Item</code> until after these dependencies had been initialized and then dynamically insert the UI into the scene graph. </p>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-49880327-7', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
